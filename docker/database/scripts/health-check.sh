#!/bin/bash
set -e

# AI Karen Database Stack Health Check Script
# This script performs comprehensive health checks on all database services

echo "üè• AI Karen Database Stack Health Check"
echo "======================================"

# Function to log with timestamp and color
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$level" in
        "INFO")
            echo -e "\033[0;32m[$timestamp] INFO: $message\033[0m"
            ;;
        "WARN")
            echo -e "\033[0;33m[$timestamp] WARN: $message\033[0m"
            ;;
        "ERROR")
            echo -e "\033[0;31m[$timestamp] ERROR: $message\033[0m"
            ;;
        "SUCCESS")
            echo -e "\033[0;36m[$timestamp] SUCCESS: $message\033[0m"
            ;;
        *)
            echo "[$timestamp] $message"
            ;;
    esac
}

# Global variables for health status
OVERALL_HEALTH="healthy"
HEALTH_ISSUES=()

# Function to record health issue
record_issue() {
    local service="$1"
    local issue="$2"
    
    OVERALL_HEALTH="unhealthy"
    HEALTH_ISSUES+=("$service: $issue")
}

# Function to check if Docker Compose is available
check_docker_compose() {
    if command -v docker-compose &> /dev/null; then
        COMPOSE_CMD="docker-compose"
    elif docker compose version &> /dev/null; then
        COMPOSE_CMD="docker compose"
    else
        log "ERROR" "Docker Compose is not available"
        exit 1
    fi
}

# Function to check PostgreSQL health
check_postgres_health() {
    local service_name="postgres"
    
    echo ""
    log "INFO" "Checking PostgreSQL health..."
    
    # Check if container is running
    if ! $COMPOSE_CMD ps "$service_name" | grep -q "Up"; then
        record_issue "$service_name" "Container not running"
        log "ERROR" "PostgreSQL container is not running"
        return 1
    fi
    
    # Check database connectivity
    local host="${POSTGRES_HOST:-localhost}"
    local port="${POSTGRES_PORT:-5432}"
    local user="${POSTGRES_USER:-karen_user}"
    local db="${POSTGRES_DB:-ai_karen}"
    local password="${POSTGRES_PASSWORD:-}"
    
    if PGPASSWORD="$password" pg_isready -h "$host" -p "$port" -U "$user" -d "$db" &> /dev/null; then
        log "SUCCESS" "PostgreSQL is accepting connections"
    else
        record_issue "$service_name" "Database not accepting connections"
        log "ERROR" "PostgreSQL is not accepting connections"
        return 1
    fi
    
    # Check database tables
    local table_count=$(PGPASSWORD="$password" psql -h "$host" -p "$port" -U "$user" -d "$db" -t -c \"\n        SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';\n    \" 2>/dev/null | tr -d ' ' || echo "0")\n    \n    log "INFO" "PostgreSQL has $table_count tables"\n    \n    # Check disk usage\n    local db_size=$(PGPASSWORD="$password" psql -h "$host" -p "$port" -U "$user\" -d \"$db\" -t -c \"\n        SELECT pg_size_pretty(pg_database_size('$db'));\n    \" 2>/dev/null | tr -d ' ' || echo \"unknown\")\n    \n    log \"INFO\" \"PostgreSQL database size: $db_size\"\n    \n    # Check active connections\n    local active_connections=$(PGPASSWORD=\"$password\" psql -h \"$host\" -p \"$port\" -U \"$user\" -d \"$db\" -t -c \"\n        SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active';\n    \" 2>/dev/null | tr -d ' ' || echo \"unknown\")\n    \n    log \"INFO\" \"PostgreSQL active connections: $active_connections\"\n    \n    log \"SUCCESS\" \"PostgreSQL health check passed\"\n    return 0\n}\n\n# Function to check Redis health\ncheck_redis_health() {\n    local service_name=\"redis\"\n    \n    echo \"\"\n    log \"INFO\" \"Checking Redis health...\"\n    \n    # Check if container is running\n    if ! $COMPOSE_CMD ps \"$service_name\" | grep -q \"Up\"; then\n        record_issue \"$service_name\" \"Container not running\"\n        log \"ERROR\" \"Redis container is not running\"\n        return 1\n    fi\n    \n    # Check Redis connectivity\n    local host=\"${REDIS_HOST:-localhost}\"\n    local port=\"${REDIS_PORT:-6379}\"\n    local password=\"${REDIS_PASSWORD:-}\"\n    \n    local redis_cmd=\"redis-cli -h $host -p $port\"\n    if [ -n \"$password\" ]; then\n        redis_cmd=\"$redis_cmd -a $password\"\n    fi\n    \n    if $redis_cmd ping | grep -q \"PONG\"; then\n        log \"SUCCESS\" \"Redis is responding to ping\"\n    else\n        record_issue \"$service_name\" \"Redis not responding to ping\"\n        log \"ERROR\" \"Redis is not responding to ping\"\n        return 1\n    fi\n    \n    # Check Redis info\n    local redis_version=$($redis_cmd info server | grep \"redis_version:\" | cut -d':' -f2 | tr -d '\\r' || echo \"unknown\")\n    log \"INFO\" \"Redis version: $redis_version\"\n    \n    # Check memory usage\n    local used_memory=$($redis_cmd info memory | grep \"used_memory_human:\" | cut -d':' -f2 | tr -d '\\r' || echo \"unknown\")\n    log \"INFO\" \"Redis memory usage: $used_memory\"\n    \n    # Check connected clients\n    local connected_clients=$($redis_cmd info clients | grep \"connected_clients:\" | cut -d':' -f2 | tr -d '\\r' || echo \"unknown\")\n    log \"INFO\" \"Redis connected clients: $connected_clients\"\n    \n    # Check keyspace\n    local total_keys=$($redis_cmd info keyspace | grep -o \"keys=[0-9]*\" | cut -d'=' -f2 | paste -sd+ | bc 2>/dev/null || echo \"0\")\n    log \"INFO\" \"Redis total keys: $total_keys\"\n    \n    log \"SUCCESS\" \"Redis health check passed\"\n    return 0\n}\n\n# Function to check Elasticsearch health\ncheck_elasticsearch_health() {\n    local service_name=\"elasticsearch\"\n    \n    echo \"\"\n    log \"INFO\" \"Checking Elasticsearch health...\"\n    \n    # Check if container is running\n    if ! $COMPOSE_CMD ps \"$service_name\" | grep -q \"Up\"; then\n        record_issue \"$service_name\" \"Container not running\"\n        log \"ERROR\" \"Elasticsearch container is not running\"\n        return 1\n    fi\n    \n    # Check Elasticsearch connectivity\n    local host=\"${ELASTICSEARCH_HOST:-localhost}\"\n    local port=\"${ELASTICSEARCH_PORT:-9200}\"\n    \n    if curl -s -f \"http://$host:$port/_cluster/health\" > /dev/null; then\n        log \"SUCCESS\" \"Elasticsearch is responding\"\n    else\n        record_issue \"$service_name\" \"Elasticsearch not responding\"\n        log \"ERROR\" \"Elasticsearch is not responding\"\n        return 1\n    fi\n    \n    # Check cluster health\n    local cluster_status=$(curl -s \"http://$host:$port/_cluster/health\" | jq -r '.status' 2>/dev/null || echo \"unknown\")\n    \n    case \"$cluster_status\" in\n        \"green\")\n            log \"SUCCESS\" \"Elasticsearch cluster status: green\"\n            ;;\n        \"yellow\")\n            log \"WARN\" \"Elasticsearch cluster status: yellow\"\n            ;;\n        \"red\")\n            record_issue \"$service_name\" \"Cluster status is red\"\n            log \"ERROR\" \"Elasticsearch cluster status: red\"\n            ;;\n        *)\n            log \"WARN\" \"Elasticsearch cluster status: $cluster_status\"\n            ;;\n    esac\n    \n    # Check node info\n    local node_count=$(curl -s \"http://$host:$port/_cluster/health\" | jq -r '.number_of_nodes' 2>/dev/null || echo \"unknown\")\n    log \"INFO\" \"Elasticsearch nodes: $node_count\"\n    \n    # Check indices\n    local index_count=$(curl -s \"http://$host:$port/_cat/indices?format=json\" | jq '. | length' 2>/dev/null || echo \"unknown\")\n    log \"INFO\" \"Elasticsearch indices: $index_count\"\n    \n    # Check disk usage\n    local disk_usage=$(curl -s \"http://$host:$port/_cat/allocation?format=json\" | jq -r '.[0].\"disk.percent\"' 2>/dev/null || echo \"unknown\")\n    log \"INFO\" \"Elasticsearch disk usage: $disk_usage%\"\n    \n    log \"SUCCESS\" \"Elasticsearch health check passed\"\n    return 0\n}\n\n# Function to check Milvus health\ncheck_milvus_health() {\n    local service_name=\"milvus\"\n    \n    echo \"\"\n    log \"INFO\" \"Checking Milvus health...\"\n    \n    # Check if container is running\n    if ! $COMPOSE_CMD ps \"$service_name\" | grep -q \"Up\"; then\n        record_issue \"$service_name\" \"Container not running\"\n        log \"ERROR\" \"Milvus container is not running\"\n        return 1\n    fi\n    \n    # Check Milvus connectivity using Python\n    if command -v python3 > /dev/null 2>&1; then\n        cat > /tmp/milvus_health_check.py << 'EOF'\n#!/usr/bin/env python3\nimport os\nimport sys\nfrom pymilvus import connections, utility\n\ndef main():\n    host = os.getenv('MILVUS_HOST', 'localhost')\n    port = os.getenv('MILVUS_PORT', '19530')\n    \n    try:\n        connections.connect(alias=\"default\", host=host, port=port)\n        \n        # Check if connection is healthy\n        collections = utility.list_collections()\n        print(f\"SUCCESS: Connected to Milvus, found {len(collections)} collections\")\n        \n        # Get server version\n        # Note: This might not be available in all Milvus versions\n        try:\n            version = utility.get_server_version()\n            print(f\"INFO: Milvus version: {version}\")\n        except:\n            print(\"INFO: Milvus version: unknown\")\n        \n        return 0\n        \n    except Exception as e:\n        print(f\"ERROR: Failed to connect to Milvus: {e}\")\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\nEOF\n        \n        chmod +x /tmp/milvus_health_check.py\n        \n        # Install pymilvus if not available\n        if ! python3 -c \"import pymilvus\" > /dev/null 2>&1; then\n            log \"INFO\" \"Installing pymilvus...\"\n            pip3 install pymilvus > /dev/null 2>&1\n        fi\n        \n        # Run health check\n        local milvus_output=$(python3 /tmp/milvus_health_check.py 2>&1)\n        \n        if echo \"$milvus_output\" | grep -q \"SUCCESS\"; then\n            log \"SUCCESS\" \"Milvus is responding\"\n            \n            # Extract collection count\n            local collection_count=$(echo \"$milvus_output\" | grep \"SUCCESS\" | grep -o \"[0-9]* collections\" | cut -d' ' -f1)\n            log \"INFO\" \"Milvus collections: $collection_count\"\n            \n            # Extract version if available\n            if echo \"$milvus_output\" | grep -q \"INFO: Milvus version:\"; then\n                local version=$(echo \"$milvus_output\" | grep \"INFO: Milvus version:\" | cut -d':' -f3 | tr -d ' ')\n                log \"INFO\" \"Milvus version: $version\"\n            fi\n        else\n            record_issue \"$service_name\" \"Milvus not responding\"\n            log \"ERROR\" \"Milvus health check failed: $milvus_output\"\n            rm -f /tmp/milvus_health_check.py\n            return 1\n        fi\n        \n        rm -f /tmp/milvus_health_check.py\n    else\n        log \"WARN\" \"Python3 not available, skipping detailed Milvus health check\"\n        \n        # Basic port check\n        local host=\"${MILVUS_HOST:-localhost}\"\n        local port=\"${MILVUS_PORT:-19530}\"\n        \n        if nc -z \"$host\" \"$port\" 2>/dev/null; then\n            log \"SUCCESS\" \"Milvus port is accessible\"\n        else\n            record_issue \"$service_name\" \"Milvus port not accessible\"\n            log \"ERROR\" \"Milvus port $port is not accessible\"\n            return 1\n        fi\n    fi\n    \n    log \"SUCCESS\" \"Milvus health check passed\"\n    return 0\n}\n\n# Function to check DuckDB health\ncheck_duckdb_health() {\n    local service_name=\"duckdb\"\n    \n    echo \"\"\n    log \"INFO\" \"Checking DuckDB health...\"\n    \n    # DuckDB runs as a file-based database, check if file exists and is accessible\n    local db_path=\"${DUCKDB_PATH:-./data/duckdb/kari_duckdb.db}\"\n    \n    if [ -f \"$db_path\" ]; then\n        log \"SUCCESS\" \"DuckDB database file exists: $db_path\"\n        \n        # Check file size\n        local file_size=$(du -h \"$db_path\" | cut -f1)\n        log \"INFO\" \"DuckDB file size: $file_size\"\n        \n        # Check if we can query the database\n        if command -v duckdb > /dev/null 2>&1; then\n            local table_count=$(duckdb \"$db_path\" \"SELECT COUNT(*) FROM information_schema.tables;\" 2>/dev/null || echo \"0\")\n            log \"INFO\" \"DuckDB tables: $table_count\"\n            \n            # Check database version\n            local version=$(duckdb \"$db_path\" \"SELECT version();\" 2>/dev/null | head -n1 || echo \"unknown\")\n            log \"INFO\" \"DuckDB version: $version\"\n        else\n            log \"WARN\" \"DuckDB CLI not available, skipping detailed checks\"\n        fi\n    else\n        log \"WARN\" \"DuckDB database file not found: $db_path\"\n        log \"INFO\" \"This is normal if DuckDB hasn't been initialized yet\"\n    fi\n    \n    log \"SUCCESS\" \"DuckDB health check passed\"\n    return 0\n}\n\n# Function to check MinIO health (if present)\ncheck_minio_health() {\n    local service_name=\"minio\"\n    \n    echo \"\"\n    log \"INFO\" \"Checking MinIO health...\"\n    \n    # Check if MinIO container is running\n    if ! $COMPOSE_CMD ps \"$service_name\" | grep -q \"Up\" 2>/dev/null; then\n        log \"INFO\" \"MinIO container not found or not running (optional service)\"\n        return 0\n    fi\n    \n    # Check MinIO API\n    local host=\"${MINIO_HOST:-localhost}\"\n    local port=\"${MINIO_PORT:-9000}\"\n    \n    if curl -s -f \"http://$host:$port/minio/health/live\" > /dev/null; then\n        log \"SUCCESS\" \"MinIO is responding\"\n    else\n        record_issue \"$service_name\" \"MinIO not responding\"\n        log \"ERROR\" \"MinIO is not responding\"\n        return 1\n    fi\n    \n    log \"SUCCESS\" \"MinIO health check passed\"\n    return 0\n}\n\n# Function to check etcd health (if present)\ncheck_etcd_health() {\n    local service_name=\"etcd\"\n    \n    echo \"\"\n    log \"INFO\" \"Checking etcd health...\"\n    \n    # Check if etcd container is running\n    if ! $COMPOSE_CMD ps \"$service_name\" | grep -q \"Up\" 2>/dev/null; then\n        log \"INFO\" \"etcd container not found or not running (optional service)\"\n        return 0\n    fi\n    \n    # Check etcd health endpoint\n    local host=\"${ETCD_HOST:-localhost}\"\n    local port=\"${ETCD_PORT:-2379}\"\n    \n    if curl -s -f \"http://$host:$port/health\" | grep -q '\"health\":\"true\"'; then\n        log \"SUCCESS\" \"etcd is healthy\"\n    else\n        record_issue \"$service_name\" \"etcd not healthy\"\n        log \"ERROR\" \"etcd is not healthy\"\n        return 1\n    fi\n    \n    log \"SUCCESS\" \"etcd health check passed\"\n    return 0\n}\n\n# Function to check overall system resources\ncheck_system_resources() {\n    echo \"\"\n    log \"INFO\" \"Checking system resources...\"\n    \n    # Check disk space\n    local disk_usage=$(df -h . | tail -n1 | awk '{print $5}' | tr -d '%')\n    if [ \"$disk_usage\" -gt 90 ]; then\n        record_issue \"system\" \"Disk usage is high: ${disk_usage}%\"\n        log \"ERROR\" \"Disk usage is critically high: ${disk_usage}%\"\n    elif [ \"$disk_usage\" -gt 80 ]; then\n        log \"WARN\" \"Disk usage is high: ${disk_usage}%\"\n    else\n        log \"SUCCESS\" \"Disk usage is acceptable: ${disk_usage}%\"\n    fi\n    \n    # Check memory usage\n    if command -v free > /dev/null 2>&1; then\n        local mem_usage=$(free | grep Mem | awk '{printf \"%.0f\", $3/$2 * 100.0}')\n        if [ \"$mem_usage\" -gt 90 ]; then\n            record_issue \"system\" \"Memory usage is high: ${mem_usage}%\"\n            log \"ERROR\" \"Memory usage is critically high: ${mem_usage}%\"\n        elif [ \"$mem_usage\" -gt 80 ]; then\n            log \"WARN\" \"Memory usage is high: ${mem_usage}%\"\n        else\n            log \"SUCCESS\" \"Memory usage is acceptable: ${mem_usage}%\"\n        fi\n    fi\n    \n    # Check Docker daemon\n    if docker system df > /dev/null 2>&1; then\n        log \"SUCCESS\" \"Docker daemon is responsive\"\n    else\n        record_issue \"system\" \"Docker daemon not responsive\"\n        log \"ERROR\" \"Docker daemon is not responsive\"\n    fi\n}\n\n# Function to generate health report\ngenerate_health_report() {\n    echo \"\"\n    echo \"===========================================\"\n    echo \"AI Karen Database Stack Health Report\"\n    echo \"Generated: $(date)\"\n    echo \"===========================================\"\n    \n    if [ \"$OVERALL_HEALTH\" = \"healthy\" ]; then\n        log \"SUCCESS\" \"Overall Status: HEALTHY ‚úÖ\"\n    else\n        log \"ERROR\" \"Overall Status: UNHEALTHY ‚ùå\"\n        \n        echo \"\"\n        log \"ERROR\" \"Issues found:\"\n        for issue in \"${HEALTH_ISSUES[@]}\"; do\n            echo \"  - $issue\"\n        done\n    fi\n    \n    echo \"\"\n    echo \"Service Status Summary:\"\n    $COMPOSE_CMD ps\n    \n    echo \"\"\n    echo \"For detailed logs, run:\"\n    echo \"  docker-compose logs [service_name]\"\n    echo \"\"\n    echo \"To restart services, run:\"\n    echo \"  ./scripts/restart.sh\"\n}\n\n# Function to show usage information\nshow_usage() {\n    echo \"AI Karen Database Stack Health Check Script\"\n    echo \"\"\n    echo \"Usage: $0 [options]\"\n    echo \"\"\n    echo \"Options:\"\n    echo \"  --service <name>  Check only specific service\"\n    echo \"  --quick          Quick check (skip detailed tests)\"\n    echo \"  --json           Output results in JSON format\"\n    echo \"  --help           Show this help message\"\n    echo \"\"\n    echo \"Services: postgres, redis, elasticsearch, milvus, duckdb, minio, etcd\"\n    echo \"\"\n    echo \"Examples:\"\n    echo \"  $0                      # Check all services\"\n    echo \"  $0 --service postgres   # Check only PostgreSQL\"\n    echo \"  $0 --quick              # Quick health check\"\n}\n\n# Main function\nmain() {\n    local specific_service=\"\"\n    local quick_check=\"false\"\n    local json_output=\"false\"\n    \n    # Parse command line arguments\n    while [[ $# -gt 0 ]]; do\n        case $1 in\n            --service)\n                specific_service=\"$2\"\n                shift 2\n                ;;\n            --quick)\n                quick_check=\"true\"\n                shift\n                ;;\n            --json)\n                json_output=\"true\"\n                shift\n                ;;\n            --help)\n                show_usage\n                exit 0\n                ;;\n            *)\n                log \"ERROR\" \"Unknown option: $1\"\n                show_usage\n                exit 1\n                ;;\n        esac\n    done\n    \n    # Check Docker Compose availability\n    check_docker_compose\n    \n    # Install required tools\n    log \"INFO\" \"Installing required tools...\"\n    if command -v apk > /dev/null 2>&1; then\n        apk add --no-cache curl postgresql-client redis jq netcat-openbsd > /dev/null 2>&1 || true\n    elif command -v apt-get > /dev/null 2>&1; then\n        apt-get update > /dev/null 2>&1 && apt-get install -y curl postgresql-client redis-tools jq netcat > /dev/null 2>&1 || true\n    fi\n    \n    # Run health checks\n    if [ -n \"$specific_service\" ]; then\n        case \"$specific_service\" in\n            \"postgres\")\n                check_postgres_health\n                ;;\n            \"redis\")\n                check_redis_health\n                ;;\n            \"elasticsearch\")\n                check_elasticsearch_health\n                ;;\n            \"milvus\")\n                check_milvus_health\n                ;;\n            \"duckdb\")\n                check_duckdb_health\n                ;;\n            \"minio\")\n                check_minio_health\n                ;;\n            \"etcd\")\n                check_etcd_health\n                ;;\n            *)\n                log \"ERROR\" \"Unknown service: $specific_service\"\n                exit 1\n                ;;\n        esac\n    else\n        # Check all services\n        check_postgres_health || true\n        check_redis_health || true\n        check_elasticsearch_health || true\n        check_milvus_health || true\n        check_duckdb_health || true\n        check_minio_health || true\n        check_etcd_health || true\n        \n        if [ \"$quick_check\" = \"false\" ]; then\n            check_system_resources\n        fi\n    fi\n    \n    # Generate report\n    if [ \"$json_output\" = \"true\" ]; then\n        # TODO: Implement JSON output format\n        log \"WARN\" \"JSON output not yet implemented, using text format\"\n    fi\n    \n    generate_health_report\n    \n    # Exit with appropriate code\n    if [ \"$OVERALL_HEALTH\" = \"healthy\" ]; then\n        exit 0\n    else\n        exit 1\n    fi\n}\n\n# Change to script directory\ncd \"$(dirname \"$0\")/..\"\n\n# Run main function with all arguments\nmain \"$@\"