"""
Extension vulnerability scanning system
"""

import ast
import json
import re
import subprocess
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Set
from sqlalchemy.orm import Session

from .models import (
    ExtensionVulnerability, VulnerabilityFinding, VulnerabilityResponse,
    SecurityLevel, VulnerabilityStatus, SecurityScanRequest, SecurityScanResult
)
from .audit_logger import ExtensionAuditLogger, AuditEventType
from ..base.exceptions import ExtensionSecurityError


class ExtensionVulnerabilityScanner:
    """Scans extensions for security vulnerabilities"""
    
    def __init__(self, db_session: Session, audit_logger: Optional[ExtensionAuditLogger] = None):
        self.db_session = db_session
        self.audit_logger = audit_logger
        
        # Known vulnerable patterns
        self.dangerous_patterns = {
            'code_injection': [
                r'eval\s*\(',
                r'exec\s*\(',
                r'subprocess\.call\s*\(',
                r'os\.system\s*\(',
                r'__import__\s*\('
            ],
            'sql_injection': [
                r'\.execute\s*\(\s*["\'].*%.*["\']',
                r'\.execute\s*\(\s*f["\'].*{.*}.*["\']',
                r'query\s*\+\s*',
                r'SELECT.*\+.*FROM'
            ],
            'path_traversal': [
                r'\.\./',
                r'\.\.\\',
                r'os\.path\.join\s*\(.*\.\.',
                r'open\s*\(.*\.\.'
            ],
            'hardcoded_secrets': [
                r'password\s*=\s*["\'][^"\']+["\']',
                r'api_key\s*=\s*["\'][^"\']+["\']',
                r'secret\s*=\s*["\'][^"\']+["\']',
                r'token\s*=\s*["\'][^"\']+["\']'
            ],
            'unsafe_deserialization': [
                r'pickle\.loads\s*\(',
                r'yaml\.load\s*\(',
                r'json\.loads\s*\(.*user'
            ]
        }
        
        # Known vulnerable dependencies
        self.vulnerable_packages = {
            'requests': {'<2.20.0': 'CVE-2018-18074'},
            'urllib3': {'<1.24.2': 'CVE-2019-11324'},
            'pyyaml': {'<5.1': 'CVE-2017-18342'},
            'jinja2': {'<2.10.1': 'CVE-2019-10906'},
            'flask': {'<1.0': 'CVE-2018-1000656'}
        }
    
    def scan_extension(
        self, 
        extension_path: Path, 
        extension_name: str,
        extension_version: str,
        scan_request: SecurityScanRequest
    ) -> SecurityScanResult:
        """Perform comprehensive security scan of an extension"""
        try:
            scan_id = f"{extension_name}_{extension_version}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
            vulnerabilities = []
            recommendations = []
            
            # Code analysis
            if 'code' in scan_request.scan_types:
                code_vulns = self._scan_code_vulnerabilities(extension_path, extension_name, extension_version)
                vulnerabilities.extend(code_vulns)
            
            # Dependency analysis
            if 'dependencies' in scan_request.scan_types:
                dep_vulns = self._scan_dependency_vulnerabilities(extension_path, extension_name, extension_version)
                vulnerabilities.extend(dep_vulns)
            
            # Permission analysis
            if 'permissions' in scan_request.scan_types:
                perm_vulns = self._scan_permission_vulnerabilities(extension_path, extension_name, extension_version)
                vulnerabilities.extend(perm_vulns)
            
            # Deep scan additional checks
            if scan_request.deep_scan:
                deep_vulns = self._perform_deep_scan(extension_path, extension_name, extension_version)
                vulnerabilities.extend(deep_vulns)
            
            # Calculate security score
            security_score = self._calculate_security_score(vulnerabilities)
            
            # Generate recommendations
            recommendations = self._generate_recommendations(vulnerabilities)
            
            # Store vulnerabilities in database
            for vuln in vulnerabilities:
                self._store_vulnerability(vuln)
            
            # Log scan completion
            if self.audit_logger:
                self.audit_logger.log_event(
                    extension_name=extension_name,
                    tenant_id="system",
                    event_type=AuditEventType.VULNERABILITY_DETECTED,
                    event_data={
                        'scan_id': scan_id,
                        'vulnerabilities_found': len(vulnerabilities),
                        'security_score': security_score,
                        'scan_types': scan_request.scan_types
                    },
                    risk_score=min(len(vulnerabilities), 10)
                )
            
            return SecurityScanResult(
                extension_name=extension_name,
                extension_version=extension_version,
                scan_id=scan_id,
                scan_types=scan_request.scan_types,
                vulnerabilities=vulnerabilities,
                security_score=security_score,
                recommendations=recommendations,
                scanned_at=datetime.utcnow()
            )
            
        except Exception as e:
            raise ExtensionSecurityError(f"Vulnerability scan failed: {e}")
    
    def _scan_code_vulnerabilities(
        self, 
        extension_path: Path, 
        extension_name: str,
        extension_version: str
    ) -> List[VulnerabilityFinding]:
        """Scan for code-level vulnerabilities"""
        vulnerabilities = []
        
        # Scan Python files
        for py_file in extension_path.rglob("*.py"):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for dangerous patterns
                for vuln_type, patterns in self.dangerous_patterns.items():
                    for pattern in patterns:
                        matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                        for match in matches:
                            line_num = content[:match.start()].count('\n') + 1
                            
                            vulnerabilities.append(VulnerabilityFinding(
                                extension_name=extension_name,
                                extension_version=extension_version,
                                vulnerability_id=f"CODE_{vuln_type.upper()}_{py_file.name}_{line_num}",
                                severity=self._get_vulnerability_severity(vuln_type),
                                title=f"{vuln_type.replace('_', ' ').title()} detected",
                                description=f"Potentially dangerous {vuln_type} pattern found in {py_file.name} at line {line_num}",
                                metadata={
                                    'file': str(py_file.relative_to(extension_path)),
                                    'line': line_num,
                                    'pattern': pattern,
                                    'match': match.group()
                                }
                            ))
                
                # AST-based analysis for more sophisticated checks
                try:
                    tree = ast.parse(content)
                    ast_vulns = self._analyze_ast(tree, py_file, extension_name, extension_version)
                    vulnerabilities.extend(ast_vulns)
                except SyntaxError:
                    # Skip files with syntax errors
                    pass
                    
            except (IOError, UnicodeDecodeError):
                # Skip files that can't be read
                continue
        
        return vulnerabilities
    
    def _scan_dependency_vulnerabilities(
        self, 
        extension_path: Path, 
        extension_name: str,
        extension_version: str
    ) -> List[VulnerabilityFinding]:
        """Scan for vulnerable dependencies"""
        vulnerabilities = []
        
        # Check requirements.txt
        req_file = extension_path / "requirements.txt"
        if req_file.exists():
            try:
                with open(req_file, 'r') as f:
                    requirements = f.read().splitlines()
                
                for req in requirements:
                    req = req.strip()
                    if not req or req.startswith('#'):
                        continue
                    
                    # Parse requirement
                    package_name, version_spec = self._parse_requirement(req)
                    
                    if package_name in self.vulnerable_packages:
                        for vuln_version, cve in self.vulnerable_packages[package_name].items():
                            if self._version_matches_vulnerability(version_spec, vuln_version):
                                vulnerabilities.append(VulnerabilityFinding(
                                    extension_name=extension_name,
                                    extension_version=extension_version,
                                    vulnerability_id=f"DEP_{package_name.upper()}_{cve}",
                                    severity=SecurityLevel.HIGH,
                                    title=f"Vulnerable dependency: {package_name}",
                                    description=f"Package {package_name} {version_spec} has known vulnerability {cve}",
                                    cve_id=cve,
                                    metadata={
                                        'package': package_name,
                                        'version_spec': version_spec,
                                        'vulnerable_version': vuln_version
                                    }
                                ))
            except IOError:
                pass
        
        # Check for safety scan if available
        try:
            safety_vulns = self._run_safety_scan(extension_path, extension_name, extension_version)
            vulnerabilities.extend(safety_vulns)
        except Exception:
            # Safety scan not available or failed
            pass
        
        return vulnerabilities
    
    def _scan_permission_vulnerabilities(
        self, 
        extension_path: Path, 
        extension_name: str,
        extension_version: str
    ) -> List[VulnerabilityFinding]:
        """Scan for permission-related vulnerabilities"""
        vulnerabilities = []
        
        # Check extension manifest
        manifest_file = extension_path / "extension.json"
        if manifest_file.exists():
            try:
                with open(manifest_file, 'r') as f:
                    manifest = json.load(f)
                
                permissions = manifest.get('permissions', {})
                
                # Check for overly broad permissions
                if permissions.get('system_access') == ['*']:
                    vulnerabilities.append(VulnerabilityFinding(
                        extension_name=extension_name,
                        extension_version=extension_version,
                        vulnerability_id=f"PERM_SYSTEM_WILDCARD",
                        severity=SecurityLevel.HIGH,
                        title="Overly broad system permissions",
                        description="Extension requests wildcard system access permissions",
                        metadata={'permissions': permissions}
                    ))
                
                if permissions.get('data_access') == ['*']:
                    vulnerabilities.append(VulnerabilityFinding(
                        extension_name=extension_name,
                        extension_version=extension_version,
                        vulnerability_id=f"PERM_DATA_WILDCARD",
                        severity=SecurityLevel.MEDIUM,
                        title="Overly broad data permissions",
                        description="Extension requests wildcard data access permissions",
                        metadata={'permissions': permissions}
                    ))
                
                # Check for network access without justification
                if 'network_access' in permissions and not manifest.get('description', '').lower().find('network'):
                    vulnerabilities.append(VulnerabilityFinding(
                        extension_name=extension_name,
                        extension_version=extension_version,
                        vulnerability_id=f"PERM_NETWORK_UNJUSTIFIED",
                        severity=SecurityLevel.MEDIUM,
                        title="Unjustified network access",
                        description="Extension requests network access without clear justification",
                        metadata={'permissions': permissions}
                    ))
                    
            except (IOError, json.JSONDecodeError):
                pass
        
        return vulnerabilities
    
    def _perform_deep_scan(
        self, 
        extension_path: Path, 
        extension_name: str,
        extension_version: str
    ) -> List[VulnerabilityFinding]:
        """Perform deep security analysis"""
        vulnerabilities = []
        
        # Check for suspicious file operations
        for py_file in extension_path.rglob("*.py"):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for file operations on sensitive paths
                sensitive_paths = ['/etc/', '/proc/', '/sys/', '/dev/', 'C:\\Windows\\', 'C:\\Program Files\\']
                for path in sensitive_paths:
                    if path in content:
                        vulnerabilities.append(VulnerabilityFinding(
                            extension_name=extension_name,
                            extension_version=extension_version,
                            vulnerability_id=f"DEEP_SENSITIVE_PATH_{py_file.name}",
                            severity=SecurityLevel.HIGH,
                            title="Access to sensitive system paths",
                            description=f"Extension accesses sensitive system path: {path}",
                            metadata={
                                'file': str(py_file.relative_to(extension_path)),
                                'sensitive_path': path
                            }
                        ))
                
                # Check for network operations
                network_patterns = [
                    r'requests\.(get|post|put|delete)',
                    r'urllib\.request',
                    r'socket\.socket',
                    r'http\.client'
                ]
                
                for pattern in network_patterns:
                    if re.search(pattern, content):
                        vulnerabilities.append(VulnerabilityFinding(
                            extension_name=extension_name,
                            extension_version=extension_version,
                            vulnerability_id=f"DEEP_NETWORK_{py_file.name}",
                            severity=SecurityLevel.MEDIUM,
                            title="Network operations detected",
                            description=f"Extension performs network operations in {py_file.name}",
                            metadata={
                                'file': str(py_file.relative_to(extension_path)),
                                'pattern': pattern
                            }
                        ))
                        break  # Only report once per file
                        
            except (IOError, UnicodeDecodeError):
                continue
        
        return vulnerabilities
    
    def _analyze_ast(
        self, 
        tree: ast.AST, 
        file_path: Path, 
        extension_name: str,
        extension_version: str
    ) -> List[VulnerabilityFinding]:
        """Analyze AST for security issues"""
        vulnerabilities = []
        
        class SecurityVisitor(ast.NodeVisitor):
            def __init__(self):
                self.vulns = []
            
            def visit_Call(self, node):
                # Check for dangerous function calls
                if isinstance(node.func, ast.Name):
                    if node.func.id in ['eval', 'exec']:
                        self.vulns.append(VulnerabilityFinding(
                            extension_name=extension_name,
                            extension_version=extension_version,
                            vulnerability_id=f"AST_DANGEROUS_CALL_{node.func.id}_{node.lineno}",
                            severity=SecurityLevel.CRITICAL,
                            title=f"Dangerous function call: {node.func.id}",
                            description=f"Use of {node.func.id} function detected at line {node.lineno}",
                            metadata={
                                'file': str(file_path.name),
                                'line': node.lineno,
                                'function': node.func.id
                            }
                        ))
                
                self.generic_visit(node)
            
            def visit_Import(self, node):
                # Check for dangerous imports
                dangerous_modules = ['os', 'subprocess', 'sys']
                for alias in node.names:
                    if alias.name in dangerous_modules:
                        self.vulns.append(VulnerabilityFinding(
                            extension_name=extension_name,
                            extension_version=extension_version,
                            vulnerability_id=f"AST_DANGEROUS_IMPORT_{alias.name}_{node.lineno}",
                            severity=SecurityLevel.MEDIUM,
                            title=f"Potentially dangerous import: {alias.name}",
                            description=f"Import of {alias.name} module detected at line {node.lineno}",
                            metadata={
                                'file': str(file_path.name),
                                'line': node.lineno,
                                'module': alias.name
                            }
                        ))
                
                self.generic_visit(node)
        
        visitor = SecurityVisitor()
        visitor.visit(tree)
        return visitor.vulns
    
    def _run_safety_scan(
        self, 
        extension_path: Path, 
        extension_name: str,
        extension_version: str
    ) -> List[VulnerabilityFinding]:
        """Run safety scan for known vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Create temporary requirements file if needed
            req_file = extension_path / "requirements.txt"
            if not req_file.exists():
                return vulnerabilities
            
            # Run safety check
            result = subprocess.run(
                ['safety', 'check', '-r', str(req_file), '--json'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                # No vulnerabilities found
                return vulnerabilities
            
            # Parse safety output
            try:
                safety_data = json.loads(result.stdout)
                for vuln in safety_data:
                    vulnerabilities.append(VulnerabilityFinding(
                        extension_name=extension_name,
                        extension_version=extension_version,
                        vulnerability_id=f"SAFETY_{vuln.get('id', 'UNKNOWN')}",
                        severity=SecurityLevel.HIGH,
                        title=f"Safety vulnerability: {vuln.get('package_name', 'Unknown')}",
                        description=vuln.get('advisory', 'No description available'),
                        cve_id=vuln.get('cve'),
                        metadata={
                            'package': vuln.get('package_name'),
                            'installed_version': vuln.get('installed_version'),
                            'vulnerable_spec': vuln.get('vulnerable_spec')
                        }
                    ))
            except json.JSONDecodeError:
                pass
                
        except (subprocess.TimeoutExpired, FileNotFoundError):
            # Safety not available or timed out
            pass
        
        return vulnerabilities
    
    def _parse_requirement(self, requirement: str) -> tuple:
        """Parse a requirement string into package name and version spec"""
        # Simple parsing - could be enhanced with proper requirement parsing
        req = requirement.strip()
        
        # Remove comments
        if '#' in req:
            req = req.split('#')[0].strip()
        
        # Extract package name and version
        for op in ['>=', '<=', '==', '>', '<', '!=']:
            if op in req:
                parts = req.split(op)
                return parts[0].strip(), f"{op}{parts[1].strip()}"
        
        return req, ""
    
    def _version_matches_vulnerability(self, version_spec: str, vuln_version: str) -> bool:
        """Check if version spec matches vulnerability condition"""
        # Simplified version matching - could be enhanced with proper version parsing
        if not version_spec:
            return True  # No version specified, assume vulnerable
        
        # This is a simplified check - in production, use proper version comparison
        if vuln_version.startswith('<'):
            # Vulnerable if version is less than specified
            return True  # Simplified - assume vulnerable for now
        
        return False
    
    def _get_vulnerability_severity(self, vuln_type: str) -> SecurityLevel:
        """Get severity level for vulnerability type"""
        severity_map = {
            'code_injection': SecurityLevel.CRITICAL,
            'sql_injection': SecurityLevel.CRITICAL,
            'path_traversal': SecurityLevel.HIGH,
            'hardcoded_secrets': SecurityLevel.HIGH,
            'unsafe_deserialization': SecurityLevel.HIGH
        }
        return severity_map.get(vuln_type, SecurityLevel.MEDIUM)
    
    def _calculate_security_score(self, vulnerabilities: List[VulnerabilityFinding]) -> float:
        """Calculate overall security score"""
        if not vulnerabilities:
            return 100.0
        
        # Score deduction based on severity
        score = 100.0
        severity_weights = {
            SecurityLevel.CRITICAL: 25,
            SecurityLevel.HIGH: 15,
            SecurityLevel.MEDIUM: 8,
            SecurityLevel.LOW: 3
        }
        
        for vuln in vulnerabilities:
            score -= severity_weights.get(vuln.severity, 5)
        
        return max(score, 0.0)
    
    def _generate_recommendations(self, vulnerabilities: List[VulnerabilityFinding]) -> List[str]:
        """Generate security recommendations based on vulnerabilities"""
        recommendations = []
        
        vuln_types = set(vuln.vulnerability_id.split('_')[1] if '_' in vuln.vulnerability_id else 'UNKNOWN' 
                        for vuln in vulnerabilities)
        
        if 'CODE' in vuln_types:
            recommendations.append("Review and sanitize code to eliminate dangerous patterns")
        
        if 'DEP' in vuln_types:
            recommendations.append("Update vulnerable dependencies to secure versions")
        
        if 'PERM' in vuln_types:
            recommendations.append("Review and minimize extension permissions")
        
        if 'DEEP' in vuln_types:
            recommendations.append("Implement additional security controls for sensitive operations")
        
        if len(vulnerabilities) > 10:
            recommendations.append("Consider comprehensive security review and testing")
        
        return recommendations
    
    def _store_vulnerability(self, vulnerability: VulnerabilityFinding) -> None:
        """Store vulnerability in database"""
        try:
            db_vuln = ExtensionVulnerability(
                extension_name=vulnerability.extension_name,
                extension_version=vulnerability.extension_version,
                vulnerability_id=vulnerability.vulnerability_id,
                severity=vulnerability.severity.value,
                title=vulnerability.title,
                description=vulnerability.description,
                cve_id=vulnerability.cve_id,
                cvss_score=vulnerability.cvss_score,
                status=VulnerabilityStatus.OPEN.value,
                detected_at=datetime.utcnow(),
                metadata=vulnerability.metadata
            )
            
            self.db_session.add(db_vuln)
            self.db_session.commit()
            
        except Exception as e:
            self.db_session.rollback()
            # Log error but don't fail the scan
            pass
    
    def get_vulnerabilities(
        self,
        extension_name: Optional[str] = None,
        status: Optional[VulnerabilityStatus] = None,
        severity: Optional[SecurityLevel] = None
    ) -> List[VulnerabilityResponse]:
        """Get stored vulnerabilities with filtering"""
        query = self.db_session.query(ExtensionVulnerability)
        
        if extension_name:
            query = query.filter(ExtensionVulnerability.extension_name == extension_name)
        
        if status:
            query = query.filter(ExtensionVulnerability.status == status.value)
        
        if severity:
            query = query.filter(ExtensionVulnerability.severity == severity.value)
        
        vulnerabilities = query.all()
        return [VulnerabilityResponse.from_orm(vuln) for vuln in vulnerabilities]
    
    def update_vulnerability_status(
        self,
        vulnerability_id: int,
        status: VulnerabilityStatus,
        updated_by: str
    ) -> bool:
        """Update vulnerability status"""
        try:
            vuln = self.db_session.query(ExtensionVulnerability).filter(
                ExtensionVulnerability.id == vulnerability_id
            ).first()
            
            if not vuln:
                return False
            
            old_status = vuln.status
            vuln.status = status.value
            
            if status == VulnerabilityStatus.FIXED:
                vuln.fixed_at = datetime.utcnow()
            
            self.db_session.commit()
            
            # Log status change
            if self.audit_logger:
                self.audit_logger.log_event(
                    extension_name=vuln.extension_name,
                    tenant_id="system",
                    event_type=AuditEventType.VULNERABILITY_DETECTED,
                    event_data={
                        'action': 'status_update',
                        'vulnerability_id': vulnerability_id,
                        'old_status': old_status,
                        'new_status': status.value
                    },
                    user_id=updated_by
                )
            
            return True
            
        except Exception as e:
            self.db_session.rollback()
            raise ExtensionSecurityError(f"Failed to update vulnerability status: {e}")